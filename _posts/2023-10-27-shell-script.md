---
layout: single
title: "UNIX/Linux 시스템 관리자를 위한 쉘 스크립트 활용 가이드 - 요약"
categories: script
tags: [unix, linux, shell]
toc: true             # Heading을 이용하여 자동으로 목차가 생성됨
---

# UNIX/Linux 기본 명령어와 개념

## 입출력 재지정 (Redirection)

| fd (file descriptor) | fd 이름 | 용도 | 표준 장치 |
| -------------------- | ------- | ---- | -------- |
| 0 | stdin (표준 입력) | 명령어에 입력할 내용을 저장 | 키보드 |
| 1 | stdout (표준 출력) | 명령어에서 출력할 내용을 저장 | 화면 |
| 2 | stderr (표준 오류) | 명령어에서 출력할 오류 메시지를 저장 | 화면 |

* 항상 명령어는 좌측, 파일은 우측에 온다는 것을 명심하자.

* fd 0과 1은 생략이 가능하다.
  - 표준 오류(2)는 반드시 표기해야 함

* 예제: 표준 입력 리디렉션
  - `명령어 < 파일`
  - `명령어 0< 파일`
```
$ cat sample.txt                    # sample.txt 파일의 내용을 보여줌
$ tr '[A-Z]' '[a-z]' < sample.txt   # sample.txt 파일의 대문자를 소문자로 바꾸고 내용을 보여줌
```

* 예제: 표준 출력 리디렉션
  - `명령어 >> 파일` ('>'는 덮어쓰기, '>>'는 이어쓰기)
  - `명령어 1>> 파일`
```
$ date >> day-time  # date 명령어의 결과를 day-time 파일로 기록
$ cat day_time      # day_time 파일 보기
```

* 예제: 표준 오류 리디렉션
  - `명령 > 파일a 2> 파일e` (명령어의 결과를 파일a에 기록하고, 오류 메시지를 파일e에 기록함)
  - `명령 1> 파일a 2> 파일e`
  - `명령 > 파일 2>&1` (명령어의 결과와 오류 메시지를 파일에 기록)
  - `명령 1> 파일 2>&1`

## 파이프 (Pipe)

* 문법: `명령어1 | 명령어2 | 명령어3`
  - 파이프는 재지정(Redirection)과 달리 파일 입출력을 하지 않고 메모리 상에서 명령어 처리 결과를 즉시 다른 명령어의 입력으로 넘기므로 속도가 빠르다.

## 기본 명령어

* at 명령어: 명령어 또는 스크립트 파일이 특정 시간에 실행되도록 *예약*
  - /etc/at.allow, /etc/at.deny 설정을 기반으로 예약 명령어에 대한 권한 부여 가능
  - atd 데몬을 구동 중이어야만 사용 가능 (/etc/init.d/atd)

* chmod 명령어: 파일, 디렉토리, 장치 등의 *권한 변경*
  - '- rwx rwx rwx': 파일 타입, 소유자 퍼미션, 소유자 그룹 퍼미션, 기타 모든 사용자의 퍼미션을 의미함
  - 8진수로 퍼미션 지정 가능: r(4), w(2), x(1) (즉, 7은 rwx, 5는 r-x를 의미함)
  - 기호를 통해 퍼미션 지정 가능: [u(소유자), g(소유자 그룹), o(기타 소유자), a(ugo 전부)]
  - 그 외에도 실행 권한 관련된 기능이 있음: SetUID(s), SetGID(s), StickyBit(t)

* chown 명령어: 파일 *소유자/소유 그룹을 변경*함 (root만 사용 가능)

* cmp 명령어: 파일을 *비교*함, diff와 달리 차이점의 유무만 알려줌

* col 명령어: 텍스트 파일 내 *개행(특수) 문자와 공백 등을 변환*하는 필터 역할을 함
  - 예: '\n\r' --> '\n', ' ' --> '\t' 등

* colcrt 명령어: *밑줄*(_)을 감추거나 변환함

* cp 명령어: 특정 파일을 현재 디렉토리 또는 다른 디렉토리로 *복사*함

* cut 명령어: 텍스트 파일이나 파이프된 결과 중에 *지정된 부분만 표시*함 (텍스트 파일 출력 편집)

* date 명령어: 시스템의 *날짜와 시간*을 알려주거나 설정함

* df 명령어: 파일 시스템의 *디스크 공간*을 표시함

* diff 명령어: 파일을 *비교*함, 차이점을 자세하게 표시함

* domainname 명령어: 운영체제에 설정된 *도메인 이름* 정보를 확인함

* du 명령어: 현재 디렉토리의 *사용량*을 표시함

* echo 명령어: 지정된 문자열을 *화면에 출력*함

* find 명령어: 조건에 맞는 *파일을 찾음*

* free 명령어: 운영체제에서 *사용/비사용* 메모리를 보여줌

* ftp 명령어: *FTP(File Transfer Protocol) 서비스*

* ifconfig 명령어: 운영체제의 *네트워크 인터페이스의 설정*을 확인 및 변경함

* grep 명령어: 텍스트 형식으로 된 파일의 내용이나 명령어의 실행 결과를 *특정 문자나 단어로 검색*함
  - 단독으로 사용하면 텍스트 파일 또는 결과의 *특정 문자나 단어가 포함된 행이 출력됨*

* logger 명령어: 운영체제의 *주요 로그 저장 파일(/var/log/messages)에 메시지를 저장*함

* lsof 명령어: list open files 명령어는 시스템에서 *열린 파일 목록*을 알려주고 *사용하는 프로세스, 디바이스 정보, 파일의 종류 등*을 표시함

* netstat 명령어: *현재 시스템에 연결되어 있는 네트워크 연결 상태 및 포트 정보*를 표시함

* nl 명령어: 텍스트 형태의 파일을 읽어 *행 번호*를 부여함

* ntpdate 명령어: 지정된 time 서버로부터 *시간 정보를 동기화*시킴

* ping 명령어: ICMP 프로토콜을 이용하여 네트워크에 연결된 *호스트의 연결 상태를 확인*하고, *호스트 간에 패킷이 왕복된 시간을 측정*하여 표시함

* pmap 명령어: 시스템의 프로세스 ID를 기준으로 *메모리 맵 정보*를 출력함

* pr 명령어: 텍스트 파일을 *인쇄가 가능한 표준 출력 형식*으로 변환함

* ps 명령어: 현재 시스템의 *프로세스 상태*를 출력함

* pwd 명령어: *현재 작업 중인 디렉토리* 이름을 출력함

* route 명령어: *네트워크 라우팅 테이블*을 출력하거나 설정함

* script 명령어: *터미널에서 수행하는 작업한 모든 내용*을 텍스트 형식으로 저장함

* sort 명령어: 텍스트 파일을 *행 단위로 정렬*함

* tail 명령어: 텍스트 파일의 *마지막 행의 내용부터 출력*함

* tar 명령어: *여러 파일들을 하나의 파일로 묶음*

* time 명령어: 특정 *프로세스나 명령어에 사용된 시스템 자원 정보*를 출력함

* touch 명령어: 0바이트의 *빈 파일을 생성*하거나, 기존 파일이 있을 경우 *파일의 수정 시간을 현재 시간으로 변경*함

* tr 명령어: 특정 문자를 *다른 문자로 변경*함

* traceroute 명령어: 네트워크 경로를 확인하기 위해 *패킷이 거쳐 가는 경로를 추적*하여, 경로 중에 네트워크 부하가 높은 곳을 찾을 때 활용됨

* uptime 명령어: *평균 시스템 부하 정보*를 출력함

* vmstat 명령어: *가상 메모리 상태*를 확인함

* w 명령어: 시스템에 *로그인한 사용자의 정보*를 출력함

## 스트림 편집기 sed

* grep처럼 정규표현식을 사용하며, 파이프를 이용하여 사용자가 필요로 하는 결과로 재처리할 수 있음
  - sed는 편집하고 있는 파일을 바꾸지 않는다.
  - sed의 연산자들은 입력 받은 모든 라인에 적용된다.

## awk (Aho Weinberger Kernighan)

* 텍스트 형태의 데이터를 *행과 열*로 구분하여 처리하고 결과를 출력하는 도구

## vi 편집기

# 쉘 프로그래밍 문법

## 쉘 프로그래밍 시작하기

### 쉘 스크립트의 일반적인 구조

* 쉘 명령어 뒤에 스크립트 파일을 옵션으로 제공하여 실행함: `sh ./script.sh`
  - 만약 스크립트 파일에게 실행 권한을 부여하면 다음과 같이 실행할 수 있음: `./script.sh`

* 첫 라인에 다음 내용을 추가: `#!/bin/sh`
  - 작성된 스크립트가 Bourne Shell임을 커널에게 알려줌

* 변수명 앞에는 $ 기호를 붙임

* 주석 앞에는 # 기호를 붙임

### 변수

* 주의사항
  - "변수명=값" 형태로 작성하며, 숫자와 문자열 아무 형태가 가능함
  - "=" 문자 좌우에 공백이 없어야 함
  - 변수의 값에 공백이 있으면 ""로 감싸야 함
  - 변수명은 영문자로 시작해야 하며, 영문자와 숫자와 밑줄문자가 사용될 수 있음
* 전역 변수
  - 현재 쉘뿐만 아니라 해당 쉘에서 파생되는 자식 프로세스에서도 사용할 수 있음
  - export 명령어로 등록할 수 있음
  - env 또는 printenv 명령어로 등록된 전역 변수 확인 가능
* 지역 변수
  - 현재의 쉘에서만 사용 가능한 변수
  - set 명령어로 등록된 지역 변수 확인 가능
  - unset 명령어로 생성된 변수를 제거할 수 있음

## 주요 문법

* 사용자 입력 받기: read <변수명>
  - 해당 명령어를 입력하고 값을 입력하면, 변수에 사용자가 입력한 값이 저장됨 (Python의 input() 함수 역할)

* 수치 연산: expr <수식>
  - 연산자: +, -, *, /, %
  - 연산자와 숫자 또는 숫자형 변수 사이에는 반드시 공백이 있어야 함
  - 괄호를 사용할 때나 * 및 / 연산 시에는 \를 반드시 사용해야 함
```
$ CALC='expr 20 + 20'
$ CALC2='expr 205 + \( 3 \* 4 \)'
$ echo $CALC
40
$ echo $CALC2
217
```

* if문
  - if의 개수만큼 fi로 반드시 조건문을 종결시켜야 함
  - 단, elif를 사용할 경우에는 종결을 위한 개수에 구애 받지 않음

```
if 조건문
  then 명령어
    elif 조건문
      then 명령어
  else 명령어
if
```

조건문을 사용한 예시는 다음과 같습니다. (코드의 각 라인은 ;을 이용하여 합칠 수도 있음)

```
#!/bin/sh

echo -n "숫자 A를 입력하세요: "
read VAR1
echo -n "숫자 B를 입력하세요: "
read VAR2

if [ $VAR1 -eq $VAR2 ]
  then echo " 숫자 A와 B는 같습니다."
    elif [ $VAR1 -ge $VAR2 ]
      then echo " 숫자 A는 B보다 크거나 같습니다."
    elif [ $VAR1 -le $VAR2 ]
      then echo " 숫자 A는 B보다 작거나 같습니다."
fi
```

* test문

...

<!--

# 시스템 관리 쉘 스크립트

# 시스템 보안 쉘 스크립트

# 나만의 시스템 관리 도구를 만들어 보자

-->
